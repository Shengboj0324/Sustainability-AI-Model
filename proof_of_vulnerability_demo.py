#!/usr/bin/env python3
"""
PROOF OF VULNERABILITY: Audit Trail Without Cryptographic Chain

This script demonstrates how an attacker with database access can:
1. Delete audit records without detection
2. Reorder records to hide actions
3. Insert backdated records
4. Modify timestamps

All while maintaining valid checksums for individual records.
"""

import json
import hashlib
from datetime import datetime, timezone, timedelta
from typing import List, Dict, Any
from dataclasses import dataclass, asdict


@dataclass
class AuditRecordWithoutChain:
    """Current implementation - NO cryptographic chain"""
    audit_id: str
    event_type: str
    timestamp: str
    entity_id: str
    action: str
    checksum: str = None
    
    def calculate_checksum(self) -> str:
        """Calculate SHA-256 checksum (WITHOUT prev_hash)"""
        data = {
            "audit_id": self.audit_id,
            "event_type": self.event_type,
            "timestamp": self.timestamp,
            "entity_id": self.entity_id,
            "action": self.action
        }
        json_str = json.dumps(data, sort_keys=True, separators=(',', ':'))
        return hashlib.sha256(json_str.encode('utf-8')).hexdigest()
    
    def verify_checksum(self) -> bool:
        """Verify individual record integrity"""
        return self.checksum == self.calculate_checksum()


@dataclass
class AuditRecordWithChain:
    """Enhanced implementation - WITH cryptographic chain"""
    audit_id: str
    event_type: str
    timestamp: str
    entity_id: str
    action: str
    prev_record_hash: str = None
    chain_index: int = 0
    checksum: str = None
    
    def calculate_checksum(self) -> str:
        """Calculate SHA-256 checksum (WITH prev_hash)"""
        data = {
            "audit_id": self.audit_id,
            "event_type": self.event_type,
            "timestamp": self.timestamp,
            "entity_id": self.entity_id,
            "action": self.action,
            "prev_record_hash": self.prev_record_hash,
            "chain_index": self.chain_index
        }
        json_str = json.dumps(data, sort_keys=True, separators=(',', ':'))
        return hashlib.sha256(json_str.encode('utf-8')).hexdigest()
    
    def verify_checksum(self) -> bool:
        """Verify individual record integrity"""
        return self.checksum == self.calculate_checksum()


def verify_chain_integrity(records: List[AuditRecordWithChain]) -> tuple[bool, str]:
    """Verify entire chain integrity"""
    if not records:
        return True, "Empty chain"
    
    prev_hash = None
    for i, record in enumerate(records):
        # Check chain index
        if record.chain_index != i:
            return False, f"Chain index mismatch at position {i}: expected {i}, got {record.chain_index}"
        
        # Check previous hash
        if record.prev_record_hash != prev_hash:
            return False, f"Chain broken at position {i}: prev_hash mismatch"
        
        # Verify checksum
        if not record.verify_checksum():
            return False, f"Invalid checksum at position {i}"
        
        prev_hash = record.checksum
    
    return True, "Chain integrity verified"


# ============================================================================
# ATTACK SCENARIO 1: Delete Record (Undetectable without chain)
# ============================================================================

print("=" * 80)
print("ATTACK SCENARIO 1: Delete Audit Record")
print("=" * 80)

# Create legitimate audit trail WITHOUT chain
records_no_chain = []
for i in range(5):
    record = AuditRecordWithoutChain(
        audit_id=f"audit-{i}",
        event_type="DOCUMENT_ACCESSED",
        timestamp=(datetime.now(timezone.utc) + timedelta(seconds=i)).isoformat(),
        entity_id=f"doc-{i}",
        action="read"
    )
    record.checksum = record.calculate_checksum()
    records_no_chain.append(record)

print(f"\n‚úÖ Original audit trail (5 records):")
for r in records_no_chain:
    print(f"  {r.audit_id}: {r.event_type} at {r.timestamp[:19]}")

# ATTACKER: Delete record 2 (the sensitive one)
print(f"\nüî¥ ATTACKER: Deleting record 'audit-2' (sensitive document access)...")
del records_no_chain[2]

print(f"\n‚ö†Ô∏è  After deletion (4 records):")
for r in records_no_chain:
    print(f"  {r.audit_id}: {r.event_type} at {r.timestamp[:19]}")

# Verify checksums (all still valid!)
print(f"\nüîç Verifying individual checksums...")
all_valid = all(r.verify_checksum() for r in records_no_chain)
print(f"  Result: {'‚úÖ ALL VALID' if all_valid else '‚ùå INVALID'}")
print(f"  ‚ö†Ô∏è  PROBLEM: Deletion is UNDETECTABLE! All checksums are still valid.")

print("\n" + "-" * 80)

# Now try the same attack WITH chain
records_with_chain = []
prev_hash = None
for i in range(5):
    record = AuditRecordWithChain(
        audit_id=f"audit-{i}",
        event_type="DOCUMENT_ACCESSED",
        timestamp=(datetime.now(timezone.utc) + timedelta(seconds=i)).isoformat(),
        entity_id=f"doc-{i}",
        action="read",
        prev_record_hash=prev_hash,
        chain_index=i
    )
    record.checksum = record.calculate_checksum()
    records_with_chain.append(record)
    prev_hash = record.checksum

print(f"\n‚úÖ Original audit trail WITH CHAIN (5 records):")
for r in records_with_chain:
    print(f"  {r.audit_id}: index={r.chain_index}, prev_hash={r.prev_record_hash[:8] if r.prev_record_hash else 'None'}...")

# ATTACKER: Try to delete record 2
print(f"\nüî¥ ATTACKER: Deleting record 'audit-2' (sensitive document access)...")
del records_with_chain[2]

print(f"\n‚ö†Ô∏è  After deletion (4 records):")
for r in records_with_chain:
    print(f"  {r.audit_id}: index={r.chain_index}, prev_hash={r.prev_record_hash[:8] if r.prev_record_hash else 'None'}...")

# Verify chain integrity
print(f"\nüîç Verifying chain integrity...")
is_valid, message = verify_chain_integrity(records_with_chain)
print(f"  Result: {'‚úÖ VALID' if is_valid else '‚ùå INVALID'}")
print(f"  Message: {message}")
print(f"  ‚úÖ SUCCESS: Deletion is DETECTED! Chain is broken.")

print("\n" + "=" * 80)
print()


# ============================================================================
# ATTACK SCENARIO 2: Reorder Records (Undetectable without chain)
# ============================================================================

print("=" * 80)
print("ATTACK SCENARIO 2: Reorder Audit Records to Hide Actions")
print("=" * 80)

# Create audit trail showing: login -> access sensitive doc -> delete doc -> logout
events = [
    ("audit-1", "USER_LOGIN", "user-123", "login"),
    ("audit-2", "DOCUMENT_ACCESSED", "sensitive-doc", "read"),
    ("audit-3", "DOCUMENT_DELETED", "sensitive-doc", "delete"),
    ("audit-4", "USER_LOGOUT", "user-123", "logout"),
]

records_no_chain = []
for i, (aid, event, entity, action) in enumerate(events):
    record = AuditRecordWithoutChain(
        audit_id=aid,
        event_type=event,
        timestamp=(datetime.now(timezone.utc) + timedelta(seconds=i)).isoformat(),
        entity_id=entity,
        action=action
    )
    record.checksum = record.calculate_checksum()
    records_no_chain.append(record)

print(f"\n‚úÖ Original sequence (shows suspicious activity):")
for r in records_no_chain:
    print(f"  {r.timestamp[:19]} | {r.event_type:20} | {r.entity_id}")

# ATTACKER: Reorder to make it look like doc was deleted BEFORE access
print(f"\nüî¥ ATTACKER: Reordering records to hide that user accessed doc before deleting...")
records_no_chain[1], records_no_chain[2] = records_no_chain[2], records_no_chain[1]

print(f"\n‚ö†Ô∏è  After reordering (looks innocent - deleted before access):")
for r in records_no_chain:
    print(f"  {r.timestamp[:19]} | {r.event_type:20} | {r.entity_id}")

# Verify checksums
all_valid = all(r.verify_checksum() for r in records_no_chain)
print(f"\nüîç Verifying individual checksums...")
print(f"  Result: {'‚úÖ ALL VALID' if all_valid else '‚ùå INVALID'}")
print(f"  ‚ö†Ô∏è  PROBLEM: Reordering is UNDETECTABLE! Timestamps are out of order but checksums are valid.")

print("\n" + "-" * 80)

# Now try WITH chain
records_with_chain = []
prev_hash = None
for i, (aid, event, entity, action) in enumerate(events):
    record = AuditRecordWithChain(
        audit_id=aid,
        event_type=event,
        timestamp=(datetime.now(timezone.utc) + timedelta(seconds=i)).isoformat(),
        entity_id=entity,
        action=action,
        prev_record_hash=prev_hash,
        chain_index=i
    )
    record.checksum = record.calculate_checksum()
    records_with_chain.append(record)
    prev_hash = record.checksum

print(f"\n‚úÖ Original sequence WITH CHAIN:")
for r in records_with_chain:
    print(f"  idx={r.chain_index} | {r.event_type:20} | prev_hash={r.prev_record_hash[:8] if r.prev_record_hash else 'None'}...")

# ATTACKER: Try to reorder
print(f"\nüî¥ ATTACKER: Reordering records...")
records_with_chain[1], records_with_chain[2] = records_with_chain[2], records_with_chain[1]

print(f"\n‚ö†Ô∏è  After reordering:")
for r in records_with_chain:
    print(f"  idx={r.chain_index} | {r.event_type:20} | prev_hash={r.prev_record_hash[:8] if r.prev_record_hash else 'None'}...")

# Verify chain
is_valid, message = verify_chain_integrity(records_with_chain)
print(f"\nüîç Verifying chain integrity...")
print(f"  Result: {'‚úÖ VALID' if is_valid else '‚ùå INVALID'}")
print(f"  Message: {message}")
print(f"  ‚úÖ SUCCESS: Reordering is DETECTED! Chain indices don't match positions.")

print("\n" + "=" * 80)
print()


# ============================================================================
# ATTACK SCENARIO 3: Insert Backdated Record (Undetectable without chain)
# ============================================================================

print("=" * 80)
print("ATTACK SCENARIO 3: Insert Backdated Record")
print("=" * 80)

# Create audit trail
records_no_chain = []
base_time = datetime.now(timezone.utc)
for i in range(3):
    record = AuditRecordWithoutChain(
        audit_id=f"audit-{i}",
        event_type="DOCUMENT_ACCESSED",
        timestamp=(base_time + timedelta(hours=i)).isoformat(),
        entity_id=f"doc-{i}",
        action="read"
    )
    record.checksum = record.calculate_checksum()
    records_no_chain.append(record)

print(f"\n‚úÖ Original audit trail (3 records):")
for r in records_no_chain:
    print(f"  {r.audit_id}: {r.timestamp[:19]}")

# ATTACKER: Insert a backdated record to create fake alibi
print(f"\nüî¥ ATTACKER: Inserting backdated record (fake alibi for time of incident)...")
fake_record = AuditRecordWithoutChain(
    audit_id="audit-fake",
    event_type="USER_LOGIN",
    timestamp=(base_time - timedelta(hours=1)).isoformat(),  # Backdated!
    entity_id="user-123",
    action="login"
)
fake_record.checksum = fake_record.calculate_checksum()
records_no_chain.insert(0, fake_record)  # Insert at beginning

print(f"\n‚ö†Ô∏è  After insertion (4 records, one backdated):")
for r in records_no_chain:
    print(f"  {r.audit_id}: {r.timestamp[:19]}")

# Verify checksums
all_valid = all(r.verify_checksum() for r in records_no_chain)
print(f"\nüîç Verifying individual checksums...")
print(f"  Result: {'‚úÖ ALL VALID' if all_valid else '‚ùå INVALID'}")
print(f"  ‚ö†Ô∏è  PROBLEM: Backdated insertion is UNDETECTABLE! Checksum is valid.")

print("\n" + "-" * 80)

# Now try WITH chain
records_with_chain = []
prev_hash = None
for i in range(3):
    record = AuditRecordWithChain(
        audit_id=f"audit-{i}",
        event_type="DOCUMENT_ACCESSED",
        timestamp=(base_time + timedelta(hours=i)).isoformat(),
        entity_id=f"doc-{i}",
        action="read",
        prev_record_hash=prev_hash,
        chain_index=i
    )
    record.checksum = record.calculate_checksum()
    records_with_chain.append(record)
    prev_hash = record.checksum

print(f"\n‚úÖ Original audit trail WITH CHAIN (3 records):")
for r in records_with_chain:
    print(f"  {r.audit_id}: idx={r.chain_index}, prev_hash={r.prev_record_hash[:8] if r.prev_record_hash else 'None'}...")

# ATTACKER: Try to insert backdated record
print(f"\nüî¥ ATTACKER: Trying to insert backdated record...")
fake_record_chain = AuditRecordWithChain(
    audit_id="audit-fake",
    event_type="USER_LOGIN",
    timestamp=(base_time - timedelta(hours=1)).isoformat(),
    entity_id="user-123",
    action="login",
    prev_record_hash=None,  # Attacker doesn't know what to put here
    chain_index=0
)
fake_record_chain.checksum = fake_record_chain.calculate_checksum()
records_with_chain.insert(0, fake_record_chain)

# Need to update all subsequent indices
for i in range(1, len(records_with_chain)):
    records_with_chain[i].chain_index = i

print(f"\n‚ö†Ô∏è  After insertion:")
for r in records_with_chain:
    print(f"  {r.audit_id}: idx={r.chain_index}, prev_hash={r.prev_record_hash[:8] if r.prev_record_hash else 'None'}...")

# Verify chain
is_valid, message = verify_chain_integrity(records_with_chain)
print(f"\nüîç Verifying chain integrity...")
print(f"  Result: {'‚úÖ VALID' if is_valid else '‚ùå INVALID'}")
print(f"  Message: {message}")
print(f"  ‚úÖ SUCCESS: Backdated insertion is DETECTED! Chain is broken.")

print("\n" + "=" * 80)
print("\n")
print("üéØ CONCLUSION:")
print("=" * 80)
print("WITHOUT cryptographic chain:")
print("  ‚ùå Cannot detect record deletion")
print("  ‚ùå Cannot detect record reordering")
print("  ‚ùå Cannot detect backdated insertions")
print("  ‚úÖ Can only detect modification of existing records")
print()
print("WITH cryptographic chain:")
print("  ‚úÖ Detects ALL tampering attempts")
print("  ‚úÖ Proves complete audit history")
print("  ‚úÖ Mathematically verifiable integrity")
print("  ‚úÖ No blockchain complexity needed")
print("=" * 80)

